#!/usr/bin/env bash
#
# CONTAINER
# A tool that builds and runs docker containers.
#
# Author JT Paasch
# License MIT <http://opensource.org/licenses/MIT>
#

# What's the name of this program?
PROGRAM=`basename $BASH_SOURCE`

# A function to explain usage.
function usage {
    echo "CONTAINER"
    echo "A tool that builds and runs docker containers."
    echo ""
    echo "-- See help:"
    echo "   $PROGRAM --help"
    echo ""
    echo "-- List container images:"
    echo "   $PROGRAM list"
    echo ""
    echo "-- List running containers."
    echo "   $PROGRAM ps"
    echo ""
    echo "-- Build a container image."
    echo "   $PROGRAM build <name> <build-path>"
    echo "       [--dockerfile <file>]"
    echo ""
    echo "-- Start/run a container."
    echo "   $PROGRAM start <name>"
    echo "       [--bash]"
    echo "       [--volume <host_path>:<container_path>]"
    echo "       [--port <host_port>:<container_port>]"
    echo "       [--link <container_name>]"
    echo ""
    echo "-- Stop a running container."
    echo "   $PROGRAM stop <name>"
    echo ""
    echo "-- Destroy a container image."
    echo "   $PROGRAM destroy <name>"
    echo ""
    echo "-- Get a running container's IP address."
    echo "   $PROGRAM ip <name>"
    echo ""
    echo "-- Get information about a running container."
    echo "   $PROGRAM info <name>"
}

# A function that explains how to get help.
function helphint {
    echo "Try: $PROGRAM --help"
}

# If no command was specified, say so and exit.
if [[ "$#" == "0" ]]; then
    echo "No command specified."
    helphint
    exit 1
fi

# What's the command that was specified?
case $1 in

    # The help option.
    -h|--help)  usage
                exit
                ;;

    # The "build" option -- builds a container image.
    build)      COMMAND="build" 
                ;;

    # The "destroy" option -- destroys a container image.
    destroy)    COMMAND="destroy"
                ;;

    # The "list" option -- lists all container images.
    list)       COMMAND="list"
                ;;

    # The "start" option -- starts/runs a container.
    start)      COMMAND="start"
                ;;

    # The "stop" option -- stop/kill a running container.
    stop)       COMMAND="stop"
                ;;

    # The "ps" option -- lists all running containers.
    ps)         COMMAND="ps"
                ;;

    # The "ip <name>" option -- gets the IP of a running container.
    ip)         COMMAND="ip"
                shift
                NAME="$1"
                ;;

    # The "info <name>" option -- gets all info about a running container.
    info)       COMMAND="info"
                shift
                NAME="$1"
                ;;

    # The "logs <name>" option -- tail the logs for a running container.
    logs)       COMMAND="logs"
                shift
                NAME="$1"
                ;;

    # Anything else is unrecognized.
    *)          echo "Invalid first argument: '$1'"
                helphint
                exit 1
                ;;

esac
shift

# Handle the "list" command.
if [[ "$COMMAND" == "list" ]]; then
    set -x
    docker images
    { set +x; } 2>/dev/null

# Handle the "ps" command.
elif [[ "$COMMAND" == "ps" ]]; then
    set -x
    docker ps -a
    { set +x; } 2>/dev/null

# Handle the "ip" command.
elif [[ "$COMMAND" == "ip" ]]; then

    # We need the name of a container, if we want to get its IP.
    if [[ -z $NAME ]]; then
        echo "Specify a container name: $PROGRAM ip <name>"
        helphint
        exit 1
    fi

    # The name can't start with a dash.
    if [[ $NAME == -* ]]; then
        echo "Specify a container name: $PROGRAM ip <name>"
        helphint
        exit 1
    fi

    # Docker image names are in the form "repo:tag". Let's split on the
    # colon and get both. If there's no tag, docker defaults to "latest".
    IFS=':' read REPO TAG <<< "$NAME"
    if [[ -z $TAG ]]; then
        TAG='latest'
    fi

    # Run "inspect" and pull out the IP address.
    set -x
    docker inspect --format '{{.NetworkSettings.IPAddress}}' "${REPO}_${TAG}"
    { set +x; } 2>/dev/null

# Handle the "info" command.
elif [[ "$COMMAND" == "info" ]]; then

    # We need the name of a container, if we want to get its info.
    if [[ -z $NAME ]]; then
        echo "Specify a container name: $PROGRAM info <name>"
        helphint
        exit 1
    fi

    # The name can't start with a dash.
    if [[ $NAME == -* ]]; then
        echo "Specify a container name: $PROGRAM info <name>"
        helphint
        exit 1
    fi

    # Docker image names are in the form "repo:tag". Let's split on the
    # colon and get both. If there's no tag, docker defaults to "latest".
    IFS=':' read REPO TAG <<< "$NAME"
    if [[ -z $TAG ]]; then
        TAG='latest'
    fi

    # Run "inspect" and get all data.
    set -x
    docker inspect "${REPO}_${TAG}"
    { set +x; } 2>/dev/null

# Handle the "logs" command.
elif [[ "$COMMAND" == "logs" ]]; then

    # Docker image names are in the form "repo:tag". Let's split on the
    # colon and get both. If there's no tag, docker defaults to "latest".
    IFS=':' read REPO TAG <<< "$NAME"
    if [[ -z $TAG ]]; then
        TAG='latest'
    fi

    # Run "logs" command.
    # Note: The logs are kept on the docker host at: 
    # /var/lib/docker/containers/<image-id>/<image-id>-json.log
    # The whole <image-id> folder is deleted when the container is deleted.
    set -x
    docker logs --follow "${REPO}_${TAG}"
    { set +x; } 2>/dev/null

# Handle the "build" command.cebc1a452171
elif [[ "$COMMAND" == "build" ]]; then

    # If no options were specified, raise an error and exit.
    if [[ "$#" == "0" ]]; then
        echo "No build options specified."
        helphint
        exit 1
    fi

    # Go through the options.
    while (( "$#" )); do
        case $1 in

            # The help option.
            -h|--help)     usage
                           exit
                           ;;

            # The --from option.
            --from)        if [[ -z $BUILD_DIR ]]; then
                               shift
                               BUILD_DIR=$1
                           else
                               echo "Specify --from only once."
                               helphint
                               exit 1
                           fi
                           ;;

            # The --dockerfile option.
            --dockerfile)  if [[ -z $DOCKERFILE ]]; then
                               shift
                               DOCKERFILE=$1
                           else
                               echo "Specify only one --dockerfile."
                               helphint
                               exit 1
                           fi
                           ;;

            # The first positional argument should be the name.
            # Anything else is unrecognized. 
            *)             if [[ -z $NAME ]]; then
                               NAME=$1
                           else
                               echo "Unrecognized option: $1"
                               helphint
                               exit 1
                           fi
                           ;;

        esac
        shift
    done

    # There must be a name for the image.
    if [[ -z $NAME ]]; then
        echo "Specify a name, e.g. $PROGRAM build db"
        helphint
        exit 1
    fi

    # Docker image names are in the form "repo:tag". Let's split on the
    # colon and get both. If there's no tag, docker defaults to "latest".
    IFS=':' read REPO TAG <<< "$NAME"
    if [[ -z $TAG ]]; then
        TAG='latest'
    fi

    # If no build directory is set, default to the current directory.
    if [[ -z $BUILD_DIR ]]; then
        BUILD_DIR='.'
    fi

    # Remove any trailing slash.
    BUILD_DIR=${BUILD_DIR%/}

    # Assume 'Dockerfile' if no DOCKERFILE is specified.
    if [[ -z $DOCKERFILE ]]; then
        DOCKERFILE='Dockerfile'
    fi

    # Try to delete the image (in case it exists already).
    echo "Deleting image $REPO:$TAG if it exists"
    docker rmi $REPO:$TAG >/dev/null

    # Now build the image fresh.
    set -x
    docker build \
           --force-rm=true \
           --no-cache=true \
           --file=$BUILD_DIR/$DOCKERFILE \
           -t $REPO:$TAG \
           $BUILD_DIR
    { set +x; } 2>/dev/null

# Handle the "destroy" command.
elif [[ "$COMMAND" == "destroy" ]]; then

    # If no options were specified, raise an error and exit.
    if [[ "$#" == "0" ]]; then
        echo "No destroy options specified."
        helphint
        exit 1
    fi

    # Go through the options.
    while (( "$#" )); do
        case $1 in

            # The help option.
            -h|--help)     usage
                           exit
                           ;;

            # Any unrecognized options (starting with a dash).
            -*)            echo "Unrecognized option: $1"
                           helphint
                           exit 1
                           ;;

            # Anything else must be the IMAGE. But only the first time
            # we encounter it. A second free option is unrecognized.
            *)             if [[ -z $IMAGE ]]; then
                               IMAGE=$1
                           else
                               echo "Unrecognized option: $1"
                               helphint
                               exit 1
                           fi
                           ;;

        esac
        shift
    done

    # We need to know which image to destroy.
    if [[ -z $IMAGE ]]; then
        echo "Specify an image to destroy, e.g. $PROGRAM destroy db"
        helphint
        exit 1
    fi

    # Docker image names are in the form "repo:tag". Let's split on the
    # colon and get both. If there's no tag, docker defaults to "latest".
    IFS=':' read REPO TAG <<< "$IMAGE"
    if [[ -z $TAG ]]; then
        TAG='latest'
    fi

    # Now destroy the container.
    set -x
    docker rmi -f $REPO:$TAG
    { set +x; } 2>/dev/null

# Handle the "start" command.
elif [[ "$COMMAND" == "start" ]]; then

    # If no options were specified, raise an error and exit.
    if [[ "$#" == "0" ]]; then
        echo "No start options specified."
        helphint
        exit 1
    fi

    # Go through the options.
    while (( "$#" )); do
        case $1 in

            # The help option.
            -h|--help)     usage
                           exit
                           ;;

            # The --bash option.
            --bash)        BASH_PATH="/bin/bash"
                           break
                           ;;

            # The --volume option. There can be many of these,
            # so we want to add them to an array.
            -v|--volume)   shift
                           if [ -z $VOLUMES ]; then
                               VOLUMES=("$1")
                           else
                               VOLUMES=("$VOLUMES" "$1")
                           fi
                           ;;

            # The --port option. There can be many of these too,
            # so we want to add them to an array.
            -p|--port)     shift
                           if [ -z $PORTS ]; then
                               PORTS=("$1")
                           else
                               PORTS=("$PORTS" "$1")
                           fi
                           ;;

            # The --link option. There can be many of these as well,
            # so we want to add them to an array.
            -l|--link)     shift
                           if [ -z $LINKS ]; then
                               LINKS=("$1")
                           else
                               LINKS=("$LINKS" "$1")
                           fi
                           ;;

            # Anything else must be the IMAGE. But only the first time
            # we encounter it. A second free parameter is unrecognized.
            *)             if [[ -z $IMAGE ]]; then
                               IMAGE=$1
                           else
                               echo "Unrecognized option: $1"
                               helphint
                               exit 1
                           fi
                           ;;

        esac
        shift
    done

    # We need to know which image to run.
    if [[ -z $IMAGE ]]; then
        echo "Specify a container to start, e.g. $CONTAINER start db"
        helphint
        exit 1
    fi

    # Docker image names are in the form "repo:tag". Let's split on the
    # colon and get both. If there's no tag, docker defaults to "latest".
    IFS=':' read REPO TAG <<< "$IMAGE"
    if [[ -z $TAG ]]; then
        TAG='latest'
    fi

    # If we have any volumes, let's expand the list into 
    # a bunch of "--volume $VOLUMES[$i]" options.
    for VOLUME in "${VOLUMES[@]}"; do
        VOLUME_OPTIONS="${VOLUME_OPTIONS} --volume ${VOLUME}"
    done

    # If we have any ports, let's expand the list into
    # a bunch of "--publish $PORTS[$i]" options.
    for PORT in "${PORTS[@]}"; do
        PORT_OPTIONS="${PORT_OPTIONS} --publish ${PORT}"
    done

    # If we have any links, let's exand the list into 
    # a bunch of "--link $LINKS[$i]" options.
    for LINK in "${LINKS[@]}"; do
        LINK_OPTIONS="${LINK_OPTIONS} --link ${LINK}"
    done

    # What log options should we use?
    # The standard json-file logger is fine, and we'll
    # put limits on the size and number of log files it creates.
    # (Note: these options seem to have no effect in my testing.)
    LOG_OPTIONS="--log-driver=json-file \
                 --log-opt max-size=2k \
                 --log-opt max-file=2 "

    # Now run the container.
    set -x
    docker run \
           -d \
           -it \
           --name "${REPO}_${TAG}" \
           $LOG_OPTIONS \
           $VOLUME_OPTIONS \
           $PORT_OPTIONS \
           $LINK_OPTIONS \
           $REPO:$TAG \
           $BASH_PATH
    { set +x; } 2>/dev/null

# Handle the "stop" command.
elif [[ "$COMMAND" == "stop" ]]; then

    # Go through the options.
    while (( "$#" )); do
        case $1 in

            # The help option.
            -h|--help)     usage
                           exit
                           ;;

            # Any unrecognized options (starting with a dash).
            -*)            echo "Unrecognized option: $1"
                           helphint
                           exit 1
                           ;;

            # Anything else must be the IMAGE. But only the first time
            # we encounter it. A second free option is unrecognized.
            *)             if [[ -z $IMAGE ]]; then
                               IMAGE=$1
                           else
                               echo "Unrecognized option: $1"
                               helphint
                               exit 1
                           fi
                           ;;

        esac
        shift
    done

    # We need to know which container to stop
    if [[ -z $IMAGE ]]; then
        echo "Specify a container to stop, e.g. $PROGRAM stop db"
        helphint
        exit 1
    fi

    # Docker image names are in the form "repo:tag". Let's split on the
    # colon and get both. If there's no tag, docker defaults to "latest".
    IFS=':' read REPO TAG <<< "$IMAGE"
    if [[ -z $TAG ]]; then
        TAG='latest'
    fi

    # Now stop the running container.
    set -x
    docker stop "${REPO}_${TAG}"
    docker rm "${REPO}_${TAG}"
    { set +x; } 2>/dev/null

# Anything else...? If so, we don't know what to do.
# It's unlikely we'll end up here, but just in case, let's give a message.
else
    echo "Nothing to do."
fi
